
  //Идентифкаторы типов данных
#define    vt_double         0      //Вещественное
#define    vt_bool           1      //Булевское  
#define    vt_int            2      //Целое

  //Направление переменной
#define    dir_input         0
#define    dir_out           1
#define    dir_inout         2

  //Флаги вызова run-функции блока
#define    f_InitState       1      //Запись начальных состояний
#define    f_UpdateOuts      2      //Обновить выходы на предварительном шаге
#define    f_GoodStep        3      //Обновить выходы на "хорошем" шаге
#define    f_GetDeri         4      //Вычислить значения правых частей дифференциальных уравнений
#define    f_GetAlgFun       5      //Вычислить значения правых частей алгебраических уравнений
#define    f_SetState        6      //Вычислить значения дискретных переменных состояния (после шага интегрирования)
#define    f_UpdateProps     7      //Обновить список параметров (с учётом флага изменяемости)
#define    f_GetJacobyState  8      //Вычислить значения дискретных переменных состояния при расчете Якобиана
#define    f_UpdateJacoby    9      //Обновить Якобиан блока
#define    f_RestoreOuts    10      //Обновить выходы после рестарта (только если очень надо, т.к. выходы всё равно будут запоминаться)
#define    f_SetAlgOut      11      //Выставить выходы блока, содержащих алгебраические переменные
#define    f_InitAlgState   12      //Выставить начальное приближение для алгебраические переменных
#define    f_Stop           13      //Вызывается при остановке расчёта (конец моделирования)
#define    f_InitObjects    14      //Инициализация объектов, массивов и т.д. (сразу после сортировки) (начало моделирования)

  //Флаги вызовов информационной функции блока
#define    i_GetBlockType    1      //Получить тип блока (источник, динамический и т.д
#define    i_GetDifCount     2      //Получить число дифференциальных переменных
#define    i_GetDisCount     3      //Если Result > 0 то обрабатывается флаг f_SetState
#define    i_GetAlgCount     4      //Получить число алгебраических переменных
#define    i_GetCount        5      //Получить размерности входов\выходов
#define    i_GetInit         6      //Получить флаг зависимости выходов от входов
#define    i_GetPropErr      7      //Проверка правильности задания параметров блока (перед сортировкой)
#define    i_HaveSpetialEditor  8   //Флаг - run-объект имеет специализированный редактор блока

  //Типы блоков (для сортировки, частотного анализа, синтеза)
#define    t_none              0    //Сервисный блок, в расчете не участвует
#define    t_src               1    //Блок-источник сигнала
#define    t_din               2    //Динамический блок
#define    t_dis               4    //Дискретный блок с состояниями            // ??? - а нужны ли эти типы блоков
#define    t_fun               8    //Функциональный блок
#define    t_dst              16    //Блок-приемник информации
#define    t_del              32    //Блоки запаздывания                       // ???
#define    t_ext              64    //Блоки-экстраполяторы                     // ???
#define    t_der             128    //Блоки-производные                        // ???
#define    t_imp             256    //Блоки-импортеры данных
#define    t_exp             512    //Блоки-экспортеры данных
#define    t_nln            1024    //Блоки-решатели нелинейных уравнений

  //Возможные результаты функций
#define    r_Success        0       //Нет ошибки
#define    r_Fail           1       //Возникла ошибка

  //Макрос - экспорт функции в DLL
#define EXPORTED_FUNC int _stdcall

  //Запись переменной
typedef struct {
  char* name;
  int   data_type;
  int   dim[3];
  int   index;
  int   direction;
  char* description;
  void* default_ptr;
  int   data_size;
} ext_var_info_record;

  //Базовые типы массивов
  //Тип - массив адресов 
typedef void*  ptr_array[10000000];
  //Тип - массив вещественных чисел
typedef double double_array[10000000];
  //Тип - массив булевский
typedef char boolean_array[10000000];
  //Тип - массив целых чисел
typedef int int_array[1000000];

  //Описание структуры для доступа к специальным переменным и методам решателя
typedef struct {
  void*   LayerContext;                  // Указатель на контекст решателя
    //Параметры интегрирования - передаются извне
  char    IntMet;                        // Метод интегрирования
  char    LoopMet;                       // Метод решения системы НАУ
  char    IsLoop;                        // Флаг метода интегрирования (явный или неявный) - для явных - True
  int     MaxLoopIt;                     // Максимальное число итераций при решении системы НАУ
  double  AbsErr;                        // Абсолютная ошибка
  double  RelErr;                        // Относительная ошибка
  double  Hmin;                          // Минимальный шаг интегрирования
  double  Hmax;                          // Максимальный шаг интегрирования

    //Параметры, задающие тип синхронизации расчета
  char    fPrecition;                    //Флаг точной синхронизации
  char    fOneStep;                      //Флаг выполнения одного шага интегрирования
  char    fFirstStep;                    //Флаг первого шага расчёта

    //Переменные управления решателем
  double  newstep;  //Новый прогнозный шаг интегрирования
  char    fsetstep;   //Флаг - установить новый шаг интегрирования

    //Эти методы используются для того чтобы зарегситрировать и удалить
    //специализированные объекты схемы (например распределённый решатель лин. уравнений)
    //Найти глобальный объект по имени   
  void* (_cdecl *FindGlobalObject)(void* ALayerContext,char* aGlobObjectName);
    //Зарегистрировать новый глобальный объект
  void (_cdecl *RegisterGlobalObject)(void* ALayerContext,char* aGlobObjectName,void* aNewObject);
    
    //Флаг необходимости повторного шага 
  char  fNeedIter;                    
    	
} solver_struct;

typedef solver_struct*  p_solver_struct;
